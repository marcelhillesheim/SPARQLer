{
  parserClass="language.parser.SparqlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sparql"
  psiImplClassSuffix="Impl"
  psiPackage="language.psi"
  psiImplPackage="language.psi.impl"

  elementTypeHolderClass="language.psi.SparqlTypes"
  elementTypeClass="language.psi.SparqlElementType"
  tokenTypeClass="language.psi.SparqlTokenType"

//  tokens=[
//    IRI_REF = "regexp:<([^<>\"{}|\^`\u0000-\u0020])*>"
//    LANGTAG = "regexp:@[a-zA-Z]+(\-[a-zA-Z0-9]+)*"
//    INTEGER = "regexp:[0-9]+"
//    DECIMAL = "regexp:[0-9]+\.[0-9]*|\.[0-9]+"
//    EXPONENT = "regexp:[eE][+-]?[0-9]+"
//    WS = "regexp:[\u0020\u0009\u000D\u000A]"
//    // TODO \u10000-\uEFFFF
//    PN_CHARS_BASE = "regexp:[A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]"
//    //TODO remove
//
//
//  ]


}

//TODO test pins (highlighting)
// pin explanation https://stackoverflow.com/questions/48701510/pin-recoverwhile-in-a-bnf-parsing


QueryUnit	  ::=  	Query
Query	  ::=  	Prologue
( SelectQuery | ConstructQuery | DescribeQuery | AskQuery )
ValuesClause
UpdateUnit	  ::=  	Update
Prologue	  ::=  	( BaseDecl | PrefixDecl )*
BaseDecl	  ::=  	KW_BASE IRIREF {pin=1}
PrefixDecl	  ::=  	KW_PREFIX PNAME_NS IRIREF {pin=1}
SelectQuery	  ::=  	SelectClause DatasetClause* WhereClause SolutionModifier
SubSelect	  ::=  	SelectClause WhereClause SolutionModifier ValuesClause
SelectClause	  ::=  	KW_SELECT ( KW_DISTINCT | KW_REDUCED )? ( ( Var | ( '(' Expression KW_AS Var ')' ) )+ | '*' ) {pin=1}
ConstructQuery	  ::=  	KW_CONSTRUCT ( ConstructTemplate DatasetClause* WhereClause SolutionModifier | DatasetClause* KW_WHERE '{' TriplesTemplate? '}' SolutionModifier ) {pin=1}
DescribeQuery	  ::=  	KW_DESCRIBE ( VarOrIri+ | '*' ) DatasetClause* WhereClause? SolutionModifier {pin=1}
AskQuery	  ::=  	KW_ASK DatasetClause* WhereClause SolutionModifier {pin=1}
DatasetClause	  ::=  	KW_FROM ( DefaultGraphClause | NamedGraphClause ) {pin=1}
DefaultGraphClause	  ::=  	SourceSelector
NamedGraphClause	  ::=  	KW_NAMED SourceSelector
SourceSelector	  ::=  	iri
WhereClause	  ::=  	KW_WHERE? GroupGraphPattern
SolutionModifier	  ::=  	GroupClause? HavingClause? OrderClause? LimitOffsetClauses?
GroupClause	  ::=  	KW_GROUP KW_BY GroupCondition+ {pin=1}
GroupCondition	  ::=  	BuiltInCall | FunctionCall | '(' Expression ( KW_AS Var )? ')' | Var
HavingClause	  ::=  	KW_HAVING HavingCondition+ {pin=1}
HavingCondition	  ::=  	Constraint
OrderClause	  ::=  	KW_ORDER KW_BY OrderCondition+ {pin=1}
OrderCondition	  ::=  	( ( KW_ASC | KW_DESC ) BrackettedExpression )
| ( Constraint | Var )
LimitOffsetClauses	  ::=  	LimitClause OffsetClause? | OffsetClause LimitClause?
LimitClause	  ::=  	KW_LIMIT INTEGER {pin=1}
OffsetClause	  ::=  	KW_OFFSET INTEGER {pin=1}
ValuesClause	  ::=  	( KW_VALUES DataBlock )?
//TODO pin rest of file
Update	  ::=  	Prologue ( Update1 ( ';' Update )? )?
Update1	  ::=  	Load | Clear | Drop | Add | Move | Copy | Create | InsertData | DeleteData | DeleteWhere | Modify
Load	  ::=  	KW_LOAD KW_SILENT? iri ( KW_INTO GraphRef )?
Clear	  ::=  	KW_CLEAR KW_SILENT? GraphRefAll
Drop	  ::=  	KW_DROP KW_SILENT? GraphRefAll
Create	  ::=  	KW_CREATE KW_SILENT? GraphRef
Add	  ::=  	KW_ADD KW_SILENT? GraphOrDefault KW_TO GraphOrDefault
Move	  ::=  	KW_MOVE KW_SILENT? GraphOrDefault KW_TO GraphOrDefault
Copy	  ::=  	KW_COPY KW_SILENT? GraphOrDefault KW_TO GraphOrDefault
InsertData	  ::=  	'INSERT DATA' QuadData
DeleteData	  ::=  	'DELETE DATA' QuadData
DeleteWhere	  ::=  	'DELETE WHERE' QuadPattern
Modify	  ::=  	( KW_WITH iri )? ( DeleteClause InsertClause? | InsertClause ) UsingClause* KW_WHERE GroupGraphPattern
DeleteClause	  ::=  	KW_DELETE QuadPattern
InsertClause	  ::=  	KW_INSERT QuadPattern
UsingClause	  ::=  	KW_USING ( iri | KW_NAMED iri )
GraphOrDefault	  ::=  	KW_DEFAULT | KW_GRAPH? iri
GraphRef	  ::=  	KW_GRAPH iri
GraphRefAll	  ::=  	GraphRef | KW_DEFAULT | KW_NAMED | KW_ALL
QuadPattern	  ::=  	'{' Quads '}'
QuadData	  ::=  	'{' Quads '}'
Quads	  ::=  	TriplesTemplate? ( QuadsNotTriples '.'? TriplesTemplate? )*
QuadsNotTriples	  ::=  	KW_GRAPH VarOrIri '{' TriplesTemplate? '}'
TriplesTemplate	  ::=  	TriplesSameSubject ( '.' TriplesTemplate? )?
GroupGraphPattern	  ::=  	'{' ( SubSelect | GroupGraphPatternSub ) '}'
GroupGraphPatternSub	  ::=  	TriplesBlock? ( GraphPatternNotTriples '.'? TriplesBlock? )*
//Todo recover
TriplesBlock	  ::=  	TriplesSameSubjectPath ( '.' TriplesBlock? )?
GraphPatternNotTriples	  ::=  	GroupOrUnionGraphPattern | OptionalGraphPattern | MinusGraphPattern | GraphGraphPattern | ServiceGraphPattern | Filter | Bind | InlineData
OptionalGraphPattern	  ::=  	KW_OPTIONAL GroupGraphPattern
GraphGraphPattern	  ::=  	KW_GRAPH VarOrIri GroupGraphPattern
ServiceGraphPattern	  ::=  	KW_SERVICE KW_SILENT? VarOrIri GroupGraphPattern
Bind	  ::=  	KW_BIND '(' Expression KW_AS Var ')'
InlineData	  ::=  	KW_VALUES DataBlock
DataBlock	  ::=  	InlineDataOneVar | InlineDataFull
InlineDataOneVar	  ::=  	Var '{' DataBlockValue* '}'
InlineDataFull	  ::=  	( NIL | '(' Var* ')' ) '{' ( '(' DataBlockValue* ')' | NIL )* '}'
DataBlockValue	  ::=  	iri | RDFLiteral | NumericLiteral | BooleanLiteral | KW_UNDEF
MinusGraphPattern	  ::=  	KW_MINUS GroupGraphPattern
GroupOrUnionGraphPattern	  ::=  	GroupGraphPattern ( KW_UNION GroupGraphPattern )*
Filter	  ::=  	KW_FILTER Constraint
Constraint	  ::=  	BrackettedExpression | BuiltInCall | FunctionCall
FunctionCall	  ::=  	iri ArgList
ArgList	  ::=  	NIL | '(' KW_DISTINCT? Expression ( ',' Expression )* ')'
ExpressionList	  ::=  	NIL | '(' Expression ( ',' Expression )* ')'
ConstructTemplate	  ::=  	'{' ConstructTriples? '}'
ConstructTriples	  ::=  	TriplesSameSubject ( '.' ConstructTriples? )?
//TODO recover for quad
TriplesSameSubject	  ::=  	VarOrTerm PropertyListNotEmpty | TriplesNode PropertyList
PropertyList	  ::=  	PropertyListNotEmpty?
//TODO recover after new line ("." ";")
PropertyListNotEmpty	  ::=  	Verb ObjectList ( ';' ( Verb ObjectList )? )*
Verb	  ::=  	VarOrIri | KW_A
ObjectList	  ::=  	Object ( ',' Object )*
Object	  ::=  	GraphNode
//TODO recover
TriplesSameSubjectPath	  ::=  	VarOrTerm PropertyListPathNotEmpty | TriplesNodePath PropertyListPath
PropertyListPath	  ::=  	PropertyListPathNotEmpty?

//TODO recover after new line ("." ";")
PropertyListPathNotEmpty	  ::=  	( VerbPath | VerbSimple ) ObjectListPath ( ';' ( ( VerbPath | VerbSimple ) ObjectListPath )? )*
//private PropertyListRecover ::= ( VerbPath | VerbSimple ) ObjectListPath {recoverWhile="RecoverList"}
//private RecoverList ::= !('.' | ';' | '{' | '}' | '(' | ')')

VerbPath	  ::=  	Path
VerbSimple	  ::=  	Var
ObjectListPath	  ::=  	ObjectPath ( ',' ObjectPath )*
ObjectPath	  ::=  	GraphNodePath
Path	  ::=  	PathAlternative
PathAlternative	  ::=  	PathSequence ( '|' PathSequence )*
PathSequence	  ::=  	PathEltOrInverse ( '/' PathEltOrInverse )*
PathElt	  ::=  	PathPrimary PathMod?
PathEltOrInverse	  ::=  	PathElt | '^' PathElt
PathMod	  ::=  	'?' | '*' | '+'
PathPrimary	  ::=  	iri | KW_A | '!' PathNegatedPropertySet | '(' Path ')'
PathNegatedPropertySet	  ::=  	PathOneInPropertySet | '(' ( PathOneInPropertySet ( '|' PathOneInPropertySet )* )? ')'
PathOneInPropertySet	  ::=  	iri | KW_A | '^' ( iri | KW_A )
//TODO name conflict --> added Lit_ --> could lead to conflicts if grammar gets updated
Lit_Integer	  ::=  	INTEGER
TriplesNode	  ::=  	Collection | BlankNodePropertyList
BlankNodePropertyList	  ::=  	'[' PropertyListNotEmpty ']'
TriplesNodePath	  ::=  	CollectionPath | BlankNodePropertyListPath
BlankNodePropertyListPath	  ::=  	'[' PropertyListPathNotEmpty ']'
Collection	  ::=  	'(' GraphNode+ ')'
CollectionPath	  ::=  	'(' GraphNodePath+ ')'
GraphNode	  ::=  	VarOrTerm | TriplesNode
GraphNodePath	  ::=  	VarOrTerm | TriplesNodePath
VarOrTerm	  ::=  	Var | GraphTerm
VarOrIri	  ::=  	Var | iri
Var	  ::=  	VAR1 | VAR2
GraphTerm	  ::=  	iri | RDFLiteral | NumericLiteral | BooleanLiteral | BlankNode | NIL
Expression	  ::=  	ConditionalOrExpression
ConditionalOrExpression	  ::=  	ConditionalAndExpression ( '||' ConditionalAndExpression )*
ConditionalAndExpression	  ::=  	ValueLogical ( '&&' ValueLogical )*
ValueLogical	  ::=  	RelationalExpression
RelationalExpression	  ::=  	NumericExpression ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression | KW_IN ExpressionList | KW_NOT KW_IN ExpressionList )?
NumericExpression	  ::=  	AdditiveExpression
AdditiveExpression	  ::=  	MultiplicativeExpression ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | ( NumericLiteralPositive | NumericLiteralNegative ) ( ( '*' UnaryExpression ) | ( '/' UnaryExpression ) )* )*
MultiplicativeExpression	  ::=  	UnaryExpression ( '*' UnaryExpression | '/' UnaryExpression )*
UnaryExpression	  ::=  	  '!' PrimaryExpression
| '+' PrimaryExpression
| '-' PrimaryExpression
| PrimaryExpression
PrimaryExpression	  ::=  	BrackettedExpression | BuiltInCall | iriOrFunction | RDFLiteral | NumericLiteral | BooleanLiteral | Var
BrackettedExpression	  ::=  	'(' Expression ')'
BuiltInCall	  ::=  	  Aggregate
| KW_STR '(' Expression ')'
| KW_LANG '(' Expression ')'
| KW_LANGMATCHES '(' Expression ',' Expression ')'
| KW_DATATYPE '(' Expression ')'
| KW_BOUND '(' Var ')'
| KW_IRI '(' Expression ')'
| KW_URI '(' Expression ')'
| KW_BNODE ( '(' Expression ')' | NIL )
| KW_RAND NIL
| KW_ABS '(' Expression ')'
| KW_CEIL '(' Expression ')'
| KW_FLOOR '(' Expression ')'
| KW_ROUND '(' Expression ')'
| KW_CONCAT ExpressionList
| SubstringExpression
| KW_STRLEN '(' Expression ')'
| StrReplaceExpression
| KW_UCASE '(' Expression ')'
| KW_LCASE '(' Expression ')'
| 'ENCODE_FOR_URI' '(' Expression ')'
| KW_CONTAINS '(' Expression ',' Expression ')'
| KW_STRSTARTS '(' Expression ',' Expression ')'
| KW_STRENDS '(' Expression ',' Expression ')'
| KW_STRBEFORE '(' Expression ',' Expression ')'
| KW_STRAFTER '(' Expression ',' Expression ')'
| KW_YEAR '(' Expression ')'
| KW_MONTH '(' Expression ')'
| KW_DAY '(' Expression ')'
| KW_HOURS '(' Expression ')'
| KW_MINUTES '(' Expression ')'
| KW_SECONDS '(' Expression ')'
| KW_TIMEZONE '(' Expression ')'
| KW_TZ '(' Expression ')'
| KW_NOW NIL
| KW_UUID NIL
| KW_STRUUID NIL
| 'MD5' '(' Expression ')'
| 'SHA1' '(' Expression ')'
| 'SHA256' '(' Expression ')'
| 'SHA384' '(' Expression ')'
| 'SHA512' '(' Expression ')'
| KW_COALESCE ExpressionList
| KW_IF '(' Expression ',' Expression ',' Expression ')'
| KW_STRLANG '(' Expression ',' Expression ')'
| KW_STRDT '(' Expression ',' Expression ')'
| KW_SAME_TERM '(' Expression ',' Expression ')'
| KW_IS_IRI '(' Expression ')'
| KW_IS_URI '(' Expression ')'
| KW_IS_BLANK '(' Expression ')'
| KW_IS_LITERAL '(' Expression ')'
| KW_IS_NUMERIC '(' Expression ')'
| RegexExpression
| ExistsFunc
| NotExistsFunc
RegexExpression	  ::=  	KW_REGEX '(' Expression ',' Expression ( ',' Expression )? ')'
SubstringExpression	  ::=  	KW_SUBSTR '(' Expression ',' Expression ( ',' Expression )? ')'
StrReplaceExpression	  ::=  	KW_REPLACE '(' Expression ',' Expression ',' Expression ( ',' Expression )? ')'
ExistsFunc	  ::=  	KW_EXISTS GroupGraphPattern
NotExistsFunc	  ::=  	KW_NOT KW_EXISTS GroupGraphPattern
Aggregate	  ::=  	  KW_COUNT '(' KW_DISTINCT? ( '*' | Expression ) ')'
| KW_SUM '(' KW_DISTINCT? Expression ')'
| KW_MIN '(' KW_DISTINCT? Expression ')'
| KW_MAX '(' KW_DISTINCT? Expression ')'
| KW_AVG '(' KW_DISTINCT? Expression ')'
| KW_SAMPLE '(' KW_DISTINCT? Expression ')'
| 'GROUP_CONCAT' '(' KW_DISTINCT? Expression ( ';' KW_SEPARATOR '=' String )? ')'
iriOrFunction	  ::=  	iri ArgList?
RDFLiteral	  ::=  	String ( LANGTAG | ( '^^' iri ) )?
NumericLiteral	  ::=  	NumericLiteralUnsigned | NumericLiteralPositive | NumericLiteralNegative
NumericLiteralUnsigned	  ::=  	INTEGER | DECIMAL | DOUBLE
NumericLiteralPositive	  ::=  	INTEGER_POSITIVE | DECIMAL_POSITIVE | DOUBLE_POSITIVE
NumericLiteralNegative	  ::=  	INTEGER_NEGATIVE | DECIMAL_NEGATIVE | DOUBLE_NEGATIVE
BooleanLiteral	  ::=  	LIT_TRUE | LIT_FALSE
String	  ::=  	STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2
iri	  ::=  	IRIREF | PrefixedName
PrefixedName	  ::=  	PNAME_LN | PNAME_NS
BlankNode	  ::=  	BLANK_NODE_LABEL | ANON